# 规格驱动开发：复杂系统的最优范式

## 1. 背景与定义

生成式AI时代，软件工程的瓶颈已从**代码生成**转向**意图对齐**。**规格驱动开发（Spec-Driven Development, SDD）** 是一种方法论，其核心主张是：人与AI之间的主要交互界面不应是代码本身，而应是一套严谨、可验证的规格说明（Spec）。

该范式明确了分工：

- **人类架构师**：聚焦「做什么」与「为何做」，通过高精度规格（API定义、状态机、Schema、含验收标准的用户故事）表达意图。
- **AI智能体**：作为「如何做」的执行引擎，将规格翻译为可运行的实现。

---

## 2. 核心假说

**SDD 是充分发挥大语言模型（LLM）在研发场景中效能的最优路径。**

该假说基于三大支柱：

| 支柱               | 说明                                                                                                                              |
| :----------------- | :-------------------------------------------------------------------------------------------------------------------------------- |
| **上下文窗口效率** | 规格是逻辑的压缩表达，相比整个代码库，更契合上下文窗口的限制。                                                                    |
| **歧义消减**       | 自然语言充满歧义；草图/图表更清晰；代码虽精确却冗长。规格语言（如 OpenAPI、Mermaid、Gherkin）恰处于精确性与简洁性的「黄金地带」。 |
| **可验证性**       | 验证实现是否符合规格，远比验证实现是否符合一段模糊的对话提示更为可行。                                                            |

---

## 3. 范式对比分析

| 维度         | 对话驱动开发 (CDD)       | 规格驱动开发 (SDD)              |
| :----------- | :----------------------- | :------------------------------ |
| **输入形态** | 对话式提示，临时性指令   | 结构化文档、Schema、图表        |
| **稳定性**   | 低（易漂移、易产生幻觉） | 高（由工件锚定）                |
| **迭代模式** | "对话直至成功"（试错法） | "编辑规格 → 重新生成"（确定性） |
| **人的角色** | 调试者、提示词工程师     | 架构师、评审者、规格撰写者      |
| **可扩展性** | 线性（上下文管理困难）   | 指数级（模块化规格易于扩展）    |

---

## 4. LLM 为何在 SDD 范式下表现卓越

| 能力         | 说明                                                                                         |
| :----------- | :------------------------------------------------------------------------------------------- |
| **结构识别** | LLM 在理解和生成结构化文本（JSON、YAML、Markdown）方面表现出色。                             |
| **约束推理** | 当提供一套规则（规格）时，LLM 能演绎式地生成遵循规则的代码，而非从模糊对话中归纳式猜测意图。 |
| **自校正**   | 智能体可先依据规格编写测试，再实现代码，形成自校正的测试驱动开发（TDD）闭环。                |

---

## 5. 经济模型

SDD 的价值呈现典型的 **J型曲线** 分布特征。

### 5.1 规格税（成本端）

| 成本项       | 说明                                               |
| :----------- | :------------------------------------------------- |
| **前置延迟** | 撰写严谨的规格需要时间（相比对话提示约增加10倍）。 |
| **同步维护** | 规格须与代码保持一致。                             |
| **技能门槛** | 需具备「架构素养」。                               |

### 5.2 重构红利（收益端）

| 收益项       | 说明                                   |
| :----------- | :------------------------------------- |
| **漂移减少** | 「这不是我要的」类型的迭代减少 90%。   |
| **验证提速** | 自动化验收测试取代人工逐一检视。       |
| **资产长效** | 规格是持久性文档；对话上下文转瞬即逝。 |

### 5.3 动态成本建模

需识别**规格债务**：因需求转向而废弃规格所产生的沉没成本。

**规格税函数**：
$$Cost = BaseCost \times (1 + VolatilityFactor)$$

**应对策略**：

| 场景   | 策略                                     |
| :----- | :--------------------------------------- |
| 高波动 | 采用**一次性规格**（轻量接口）           |
| 低波动 | 投资**耐久规格**（完整 OpenAPI/Gherkin） |

**工具化要务**：SDD 的投资回报率取决于工具成熟度。需要一个将规格视为「活文档」的 **Spec IDE**：

1. **逆向工程**：从现有代码/对话自动生成规格草稿
2. **双向同步**：代码变更时，规格同步更新（或触发告警）
3. **AI审计**：编码前实时识别并批判歧义之处

**动态成本修正因子**：

| 因子                     | 范围      | 说明                                                 |
| :----------------------- | :-------- | :--------------------------------------------------- |
| **团队熟练度因子 (TPF)** | 0.5 - 1.5 | 基于团队的架构素养。经验不足的团队承担更高「规格税」 |
| **需求波动折扣率 (RVD)** | 0.7 - 1.0 | 基于历史需求变更频率。高波动削弱规格长期价值         |

> **修正决策公式**：`Final RTCR = Base RTCR × TPF / RVD`
>
> 示例：低熟练度团队 (TPF=1.3) + 高波动项目 (RVD=0.8) → RTCR 膨胀约 60%，SDD 可能从「最优」降级为「边际可行」。

### 5.4 盈亏平衡点

SDD 在以下条件下实现正 ROI：

| 条件             | 阈值                                 |
| :--------------- | :----------------------------------- |
| **系统复杂度**   | > 5 个交互组件                       |
| **代码生命周期** | > 1 个月（需持续维护）               |
| **需求稳定性**   | > 中等（若每日转向，应继续使用 CDD） |

---

## 6. 挑战与应对

### 6.1 核心挑战

| 挑战           | 说明                                               |
| :------------- | :------------------------------------------------- |
| **规格税负担** | 撰写优质规格具有难度。开发者普遍抵触编写文档。     |
| **僵化风险**   | 过度规格化可能扼杀创意方案或AI本可发现的优化机会。 |
| **工具缺口**   | 目前缺乏能与AI编码器无缝集成的成熟「Spec IDE」。   |

> ⚠️ **关键约束**：本范式的可行性依赖于 **Spec IDE MVP（第8节）**。在该工具链落地并验证其ROI之前，SDD 应被视为**高风险/高回报**的方法，须确保「规格税」不会压垮项目。

### 6.2 规格质量保证 (SQA)

为防止「精修垃圾」和「合规陷阱」：

| 措施             | 说明                                               |
| :--------------- | :------------------------------------------------- |
| **最小可行约束** | SQA 应拒绝*过度规格化*。目标是对齐，而非官僚主义。 |
| **静态检查**     | 自动校验 Schema，但对过度复杂给出警告。            |
| **评审机制**     | AI智能体应批判歧义，而非仅检查格式。               |
| **最小定义**     | 接口定义 + 验收标准 (Gherkin) 即可。               |

### 6.3 渐进式规格化

避免「大设计先行」。将规格覆盖率视同测试覆盖率：

| 阶段                | 策略                                           |
| :------------------ | :--------------------------------------------- |
| **阶段1（MVP）**    | 仅规格化**核心接口**与**关键流程**（最小定义） |
| **阶段2（成长期）** | 随模块稳定，逐步提升**规格覆盖率**             |

**度量指标**：跟踪 `Spec-Verified-Lines-of-Code`，平衡投入与成熟度。

---

## 7. 混合框架：情境驱动的范式选择

一刀切并不适用。

### 7.1 选择矩阵

| 系统复杂度          | 需求清晰度              | 推荐范式 | 策略                                                   |
| :------------------ | :---------------------- | :------- | :----------------------------------------------------- |
| **低**（脚本/函数） | **低**（模糊概念）      | **CDD**  | 「探索性编码」- 用对话快速原型，随用随弃               |
| **低**              | **高**（明确输入/输出） | **SDD**  | 「直接执行」- 提供签名/Schema，获取代码                |
| **高**（微服务）    | **低**                  | **混合** | 「原型循环」- 用对话澄清需求，智能体渐进式构建规格草稿 |
| **高**              | **高**                  | **SDD**  | 「工业化建造」- 这是实现稳定性的唯一可行路径           |

### 7.2 「活规格」工作流

为弥合探索与结晶之间的鸿沟，采用**实时抽取**流程：

```
┌─────────────────────────────────────────────────────────────────┐
│  ① 探索（对话）                                                  │
│     用户与AI讨论需求                                             │
│                          ↓                                      │
│  ② 抽取（后台）                                                  │
│    「抄书员智能体」并行运行，生成【活规格草稿】                     │
│                          ↓                                      │
│  ③ 校验（半自动化）                                              │
│     系统高亮【低置信度】区域与【歧义标记】                         │
│     用户快速确认/修正                                            │
│                          ↓                                      │
│  ④ 冻结（里程碑）                                                │
│     用户点击「批准草稿」，规格被版本化                             │
│                          ↓                                      │
│  ⑤ 执行（构建）                                                  │
│    「构建者智能体」基于冻结规格进行实现                            │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. Spec IDE MVP：关键工具枢纽

### 8.1 核心目标

**Spec IDE MVP** 的首要目标是**将「规格税」降至与「对话驱动调试税」相当的水平**，将规格撰写从手工负担转变为半自动化的验证任务。

> ⚠️ **风险门控**：MVP 的成功以**第9节可行性验证**为门控条件。若验证未达预设基准，MVP 范围将收缩为仅「逆向工程 + 静态检查器」；「抄书员智能体」的实时抽取功能将延后至长期研发。

### 8.2 MVP 功能集

> 💡 **降级设计**：为对冲技术风险，MVP 采用**渐进交付策略**，优先交付保守版 V1，再尝试实时功能。

#### 8.2.1 抄书员智能体集成

**V1：会话后综合**（核心交付物）

- 需求对话结束后，用户点击「生成规格」，触发对完整对话历史的离线分析
- 智能体产出结构化的 `活规格草稿`（Markdown/YAML）
- 用户对生成草稿进行批量评审与修订
- **用户体验目标**：「评审与编辑」界面须通过**行内差异对比**、**置信度评分**、**一键接受/拒绝**降低认知负荷，让修订感觉像「校对」而非「重写」

**V2：实时抽取**（延后）

- 对话过程中后台监听并实时抽取实体
- **门控条件**：V2 的实施取决于 V1 用户反馈及独立的技术可行性评估

#### 8.2.2 歧义检查器

- 针对自然语言的静态分析引擎
- **置信度评分**：以红色下划线标记模糊术语（如「快速」「用户友好」）及缺失的验收标准
- **自动建议**：提供精确替代方案（如「响应时间 < 200ms」）

#### 8.2.3 一键版本化

- 「冻结」按钮：快照草稿、提交至 Git、并生成唯一 **Spec ID** 供构建者智能体引用

### 8.3 成功指标

| 维度     | 指标                                                 | 目标值    |
| :------- | :--------------------------------------------------- | :-------- |
| **效率** | 30分钟复杂需求会话 → 80%覆盖率规格草稿，用户修订时间 | < 10 分钟 |
| **采纳** | 开发者倾向「评审草稿」而非「从头撰写提示词」的比例   | > 90%     |
| **成本** | MVP 开发周期                                         | ≤ 3 人月  |
| **维护** | 年度维护成本占开发成本比例                           | < 20%     |

---

## 9. 渐进式证据收集方案

在全面投入 MVP 开发之前，采用**分阶段验证方法**替代单点探测，以降低「孤注一掷」风险。

### 9.1 阶段零：工具能力基准测试

> 📋 **前置条件**：在任何价值评估之前，独立验证抄书员智能体的核心能力。

| 指标               | 目标值 | 方法                                                              |
| :----------------- | :----- | :---------------------------------------------------------------- |
| **规格草稿准确率** | > 90%  | 将AI生成规格与专家「黄金规格」对比，以实体/关系精确率、召回率衡量 |
| **结构完整性**     | > 95%  | 生成规格中语法有效（YAML/JSON）且符合最小定义的比例               |
| **歧义识别率**     | > 85%  | 源对话中模糊术语被正确识别并标记的比例                            |

- **范围**：20 条经脱敏处理的对话日志，复杂度从简单（1个组件）到复杂（≥6个组件）
- **门控**：阶段零须达成全部目标，方可为阶段A分配资源

### 9.2 阶段A：微观验证

> 📋 **目标**：在可控、低风险环境中验证 SDD 的价值。

| 指标              | 目标值       | 方法                                        |
| :---------------- | :----------- | :------------------------------------------ |
| **首次通过率**    | > 85%        | AI生成代码无需人工干预即通过测试的比例      |
| **3个月变更成本** | < CDD 的 50% | 对比在SDD与CDD模块中实现3个需求变更的工作量 |

- **范围**：单一稳定API模块（如用户认证）
- **周期**：4周实施 + 12周观察

### 9.3 阶段B：流程验证

> 📋 **目标**：在「活规格」作为可选工具提供时，测量自然采纳率与满意度。

| 指标                 | 目标值 | 方法                                 |
| :------------------- | :----- | :----------------------------------- |
| **自然采纳率**       | > 60%  | 初次培训后自愿使用该工具的开发者比例 |
| **用户满意度 (NPS)** | > 40   | 使用后问卷调查的净推荐值             |

- **范围**：真实项目，3-5名开发者，2个迭代周期
- **环境**：抄书员智能体V1原型以可选VS Code扩展形式集成

### 9.4 阶段C：混合式 RTCR 验证

> 📋 **前置条件**：阶段A与阶段B须呈现积极信号，方可进入本阶段。

本阶段采用**混合方法**，结合受控实验与回顾性分析。

#### 第一部分：受控实验

> **主要指标**：**相对总成本比 (RTCR)** = `总时间(SDD) / 总时间(CDD)`
> **目标**：RTCR < 0.85（经TPF与RVD修正）

| 指标                 | 目标值    | 方法                                           |
| :------------------- | :-------- | :--------------------------------------------- |
| **修正后 RTCR**      | < 0.85    | 从需求到验证代码的端到端时间，应用成本修正因子 |
| **规格草稿修订时间** | < 15 分钟 | 综合阶段的时间（基于阶段零结果调整）           |
| **代码验证通过率**   | > 95%     | 首次运行验收测试的通过率                       |

- **样本集**：5个场景，每个场景 ≥ 6 个交互组件
- **环境**：双阶段流程（对话阶段 + 综合阶段），模拟V1工作流

#### 第二部分：回顾性分析

- **目标**：在真实场景中验证RTCR，缓解受控实验的人工性
- **方法**：选取1-2个进行中的志愿项目，部署Spec IDE V1，收集2个迭代周期的数据，对比处理相似复杂度变更请求的实际时间、沟通开销、返工率与基线期（CDD）表现
- **成功标准**：回顾性分析须呈现**统计显著趋势**（如返工率降低 > 20%），以支撑第一部分的RTCR发现

### 9.5 决策矩阵

| 阶段零 | 阶段A | 阶段B | 阶段C | 决策                                                 |
| :----: | :---: | :---: | :---: | :--------------------------------------------------- |
|   ❌   |   -   |   -   |   -   | **终止抄书员智能体**；仅聚焦检查器 + 逆向工程        |
|   ✅   |  ❌   |   -   |   -   | 重新评估抄书员智能体核心技术；暂停价值验证           |
|   ✅   |  ✅   |  ✅   |  ✅   | **全面启动V1开发** + 制定V2路线图                    |
|   ✅   |  ✅   |  ✅   |  ⚠️   | 缩减范围的V1；观察后再决策V2（须有强回顾性数据支撑） |
|   ✅   |  ✅   |  ⚠️   |  ❌   | 仅向「高清晰度」团队提供V1；延后更广泛推广           |

---

## 10. 结论

规格驱动开发并非对话驱动的替代品，而是其**演进形态**。

对于**复杂的企业级系统**，它呈现了**通向最优范式的最具前景路径**，但须满足以下条件：

| 条件     | 说明                                              |
| :------- | :------------------------------------------------ |
| **验证** | 成功完成**可行性验证（第9节）**，确认核心假设成立 |
| **落地** | 基于验证结果开发**Spec IDE工具链（第8节）**       |

> 🎯 **未来属于那些不仅能构想可执行规格、更能在规模化之前验证其工程可行性的人。**

---

## 附录：术语表

| 英文术语                      | 中文译法       | 说明                       |
| :---------------------------- | :------------- | :------------------------- |
| Spec-Driven Development (SDD) | 规格驱动开发   | 以规格为核心的开发范式     |
| Chat-Driven Development (CDD) | 对话驱动开发   | 以对话为核心的开发范式     |
| Spec Tax                      | 规格税         | 撰写与维护规格的成本       |
| Refactoring Dividend          | 重构红利       | 规格带来的长期收益         |
| Living Spec                   | 活规格         | 动态演进的规格文档         |
| Scribe Agent                  | 抄书员智能体   | 负责从对话中抽取规格的AI   |
| Builder Agent                 | 构建者智能体   | 负责基于规格生成代码的AI   |
| Ambiguity Linter              | 歧义检查器     | 识别规格中模糊表述的工具   |
| RTCR                          | 相对总成本比   | 衡量SDD与CDD效率对比的指标 |
| TPF                           | 团队熟练度因子 | 成本修正系数               |
| RVD                           | 需求波动折扣率 | 收益修正系数               |
